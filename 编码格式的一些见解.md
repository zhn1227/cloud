引言：一个汉字是几个字节 ？

​	 	 1?	2?	3?	4? 

# 一、什么是位、字节、字？

**位**（bit）：由值0和1表示，计算机最基本单位。

**字节**（byte）：8个二进制位构成1个"字节(Byte)"，它是存储空间的基本计量单位。

**字**（word）："字"由若干个字节构成，不同档次的机器有不同的字长。例如一台8位机，它的1个字就等于1个字节，字长为8位。如果是一台16位机，那么，它的1个字就由2个字节构成，字长为16位。字是计算机进行数据处理和运算的单位。

# 二、几种编码格式的简单介绍

- **ASCII** 

  ​	ASCII 码，总共有 125个，用一个字节的低 7 位表示，0~31 是控制字符如换行回车删除等；32~126 是打印字符，可以通过键盘输入并且能够显示出来。

- **`ISO-8859-1`**

  ​	128 个字符显然是不够用的，于是 ISO 组织在 ASCII 码基础上又制定了一些列标准用来扩展 ASCII 编码，它们是 ISO-8859-1~ISO-8859-15，其中 ISO-8859-1 涵盖了大多数西欧语言字符，所有应用的最广泛。ISO-8859-1 仍然是单字节编码，它总共能表示 256 个字符。

- **GB2312**

  ​	它的全称是《信息交换用汉字编码字符集 基本集》，它是双字节编码，总的编码范围是 A1-F7，其中从 A1-A9 是符号区，总共包含 682 个符号，从 B0-F7 是汉字区，包含 6763 个汉字。

- **GBK**

  ​	全称叫《汉字内码扩展规范》，是国家技术监督局为 windows95 所制定的新的汉字内码规范，它的出现是为了扩展 GB2312，加入更多的汉字，它的编码范围是 8140~FEFE（去掉 XX7F）总共有 23940 个码位，它能表示 21003 个汉字，它的编码是和 GB2312 兼容的，也就是说用 GB2312 编码的汉字可以用 GBK 来解码，并且不会有乱码。

- **GB18030**

  ​	全称是《信息交换用汉字编码字符集》，是我国的强制标准，它可能是单字节、双字节或者四字节编码，它的编码与 GB2312 编码兼容，这个虽然是国家标准，但是实际应用系统中使用的并不广泛。

- **UTF-16**

  ​	说到 UTF 必须要提到 Unicode（Universal Code 统一码），ISO 试图想创建一个全新的超语言字典，世界上所有的语言都可以通过这本字典来相互翻译。可想而知这个字典是多么的复杂，关于 Unicode 的详细规范可以参考相应文档。Unicode 是 Java 和 XML 的基础，下面详细介绍 Unicode 在计算机中的存储形式。

  ​	UTF-16 具体定义了 Unicode 字符在计算机中存取方法。UTF-16 用两个字节来表示 Unicode 转化格式，这个是定长的表示方法，不论什么字符都可以用两个字节表示，两个字节是 16 个 bit，所以叫 UTF-16。UTF-16 表示字符非常方便，每两个字节表示一个字符，这个在字符串操作时就大大简化了操作，这也是 Java 以 UTF-16 作为内存的字符存储格式的一个很重要的原因。

- **UTF-8**

  ​	UTF-16 统一采用两个字节表示一个字符，虽然在表示上非常简单方便，但是也有其缺点，有很大一部分字符用一个字节就可以表示的现在要两个字节表示，存储空间放大了一倍，在现在的网络带宽还非常有限的今天，这样会增大网络传输的流量，而且也没必要。而 UTF-8 采用了一种变长技术，每个编码区域有不同的字码长度。不同类型的字符可以是由 1~6 个字节组成。

# 三、“0“和”1“的艺术

​		大家应该都知道，计算机是不理解它输入输出，也就是我们输进去和看到的那些内容的，它只是在根据既定的规则将输入的数据进行特定的处理，然后再输出，由于计算机内数据和指令的存储和处理都是由晶体管和门电路等元件完成的，而这些元件实际上都只能表达出两种状态：开和关，这也是唯一能真正被计算机所“理解”的两个东西。这种特性正好与二进制的理念不谋而合，因此二进制就理所当然的成为了计算机的基础计数法，人们一般用1代表晶体管的“开”状态，0代表“关”的状态。计算机的一系列理论和结构进化都是基于二进制进行的。ENIAC上的程序也是直接由二进制代码构成，再手动改变计算机的硬件结构以实现编程，这种直接由二进制代码组成的程序语言叫**机器语言**。



# 四、字符编码的历史故事

## 计算机的诞生

很久以前有一群聪明人他们决定用8个可以开合晶体管来组合成不同的状态，来表示人类所能理解的数字和符号，他们把这8个晶体管称为字节。

再后来，他们又做了一些可以处理这些字节的机器，机器开动了，可以用字节来组合出更多的状态，状态开始变来变去。他们看到这样是好的，于是它们就这机器称为"计算机"。 

于是世界上第一台**通用**计算机“ENIAC”['i: *niæk*]于1946年2月14日在美国宾夕法尼亚大学诞生

[  ABC](https://baike.baidu.com/item/ABC/5534473)（**阿塔纳索夫-贝瑞计算机**）之后的第一台***电子计算机***。

值得一提的是开发小组4个人中，有一个是美籍华人朱传榘先生，天津人，43年加入美国国籍，上交大的名誉教授

八位的字节一共可以组合出256（2的8次方）种不同的状态。 

## ASCII

他们把其中的编号从0开始的32种状态分别规定了特殊的用途，一但终端设备或者打印机遇上这些约定好的字节时，就要做一些约定的动作。遇上 00x10, 终端就换行，遇上0x07, 终端就向人们嘟嘟叫，例好遇上0x1b, 打印机就打印反白的字，对于终端就用彩色显示字母。他们看到这样很好，于是就把这些0x20（十进制32）以下的字节状态称为"控制码"。 

他们又把所有的空格、标点符号、数字、大小写字母分别用连续的字节状态表示，一直编到了第127号，这样计算机就可以用不同字节来存储英语的 文字了。大家看到这样，都感觉很好，于是大家都把这个方案叫做 ANSI 的"Ascii"编码（American Standard Code for Information Interchange，美国信息互换标准代码）。当时世界上所有的计算机都用同样的ASCII['æski]方案来保存英文文字。 

![ascii](/root/桌面/张浩楠/ascii.jpg)

## ISO-8859-1

​		后来，就像建造巴比伦塔一样，世界各地的都开始使用计算机，但是很多国家(西欧部分)用的不是英文，他们用到的许多字母在ASCII中根本没有，为了也可以在计算机中保存他们的文字，他们决定采用127号之后的空位来表示这些新的字母、符号，还加入了很多画表格时需要用下到的横线、竖线、交叉等形状，一直把序号编到了最后一个状态255。从128到255这一页的字符集被称"扩展字符集"。从此之后，贪婪的人类再没有新的状态可以用了，美帝国主义可能没有想到还有第三世界国家的人们也希望可以用到计算机吧！ 

## GB2312

​		等中国人们得到计算机时，已经没有可以利用的字节状态来表示汉字，况且有6000多个常用汉字需要保存呢。但是这难不倒智慧的中国人民，我们不客气地把那些127号之后的奇异符号们直接取消掉，并且规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节（称之为高字节）从0xA1用到 0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。在这些编码里，我们还把数学符号、罗马希腊的字母、日文的假名们都编进去了，连在 ASCII 里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的"全角"字符，而原来在127号以下的那些就叫"半角"字符了。 

​		中国人民看到这样很不错，于是就把这种汉字方案叫做"GB2312"。**GB2312 是对 ASCII 的中文扩展**。 

## GBK

​		但是中国的汉字太多了，我们很快就就发现有许多人的人名没有办法在这里打出来，特别是某些很会麻烦别人的国家领导人（如朱镕基的“镕”字）。于是我们不得不继续把 GB2312 没有用到的码位找出来老实不客气地用上。 

​		后来还是不够用，于是干脆不再要求低字节一定是127号之后的内码，只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的内容。结果扩展之后的编码方案被称为 GBK 标准，GBK 包括了 GB2312 的所有内容，同时又增加了近20000个新的汉字（包括繁体字）和符号。

##  GB18030

​		后来少数民族也要用电脑了，于是我们再扩展，又加了几千个新的少数民族的字，GBK 扩成了 GB18030。从此之后，中华民族的文化就可以在计算机时代中传承了。 

​		中国的程序员们看到这一系列汉字编码的标准是好的，于是通称他们叫做 "**DBCS**"（Double Byte Charecter Set 双字节字符集）。在DBCS系列标准里，**最大的特点是两字节长的汉字字符和一字节长的英文字符并存于同一套编码方案里**，因此他们写的程序为了支持中文处理，必须要注意字串里的每一个字节的值，如果这个值是大于127的，那么就认为一个双字节字符集里的字符出现了。那时候凡是受过加持，会编程的计算机僧侣们都要每天念下面这个咒语数百遍： 

​		"一个汉字算两个英文字符！一个汉字算两个英文字符……" 

## UNICODE标准

​		因为当时各个国家都像中国这样搞出一套自己的编码标准，结果互相之间谁也不懂谁的编码，谁也不支持别人的编码，连大陆和台湾这样只相隔了150海里，使用着同一种语言的兄弟地区，也分别采用了不同的 DBCS 编码方案——当时的中国人想让电脑显示汉字，就必须装上一个"汉字系统"，专门用来处理汉字的显示、输入的问题，但是那个台湾的愚昧封建人士写的算命程序就必须加装另一套支持 BIG5 编码的什么"倚天汉字系统"才可以用，装错了字符系统，显示就会乱了套！这怎么办？而且世界民族之林中还有那些一时用不上电脑的穷苦人民，他们的文字又怎么办？ 

​		正在这时，一个叫 ISO （国际标谁化组织）的国际组织决定着手解决这个问题。他们采用的方法很简单：废了所有的地区性编码方案，重新搞一个包括了地球上所有文化、所有字母和符号的编码！他们打算叫它"Universal Multiple-Octet Coded Character Set"，简称 UCS, 俗称 "**UNICODE**"。 

​		UNICODE 开始制订时，计算机的存储器容量极大地发展了，空间再也不成为问题了。于是 ISO 就直接规定必须用两个字节，也就是16位来统一表示所有的字符，对于ascii里的那些"半角"字符，UNICODE 包持其原编码不变，只是将其长度由原来的8位扩展为16位，而其他文化和语言的字符则全部重新统一编码。由于"半角"英文符号只需要用到低8位，所以其高 8位永远是0，因此这种大气的方案在保存英文文本时会多浪费一倍的空间。 

​		这时候，从旧社会里走过来的程序员开始发现一个奇怪的现象：他们的strlen函数(计算字符串长度)靠不住了，一个汉字不再是相当于两个字符了，而是一个！，是 的，从 UNICODE 开始，无论是半角的英文字母，还是全角的汉字，它们都是统一的"一个字符"！同时，也都是统一的"两个字节"，请注意"字符"和"字节"两个术语的不同， "字节"是一个8位的物理存贮单元，而"字符"则是一个文化相关的符号。在UNICODE 中，一个字符就是两个字节。一个汉字算两个英文字符的时代已经快过去了。 

​		从前多种字符集存在时，那些做多语言软件的公司遇上过很大麻烦，他们为了在不同的国家销售同一套软件，就不得不在区域化软件时也加持那个双字节字符集咒语，不仅要处处小心不要搞错，还要把软件中的文字在不同的字符集中转来转去。UNICODE 对于他们来说是一个很好的一揽子解决方案，于是从 Windows NT 开始，MS 趁机把它们的操作系统改了一遍，把所有的核心代码都改成了用 UNICODE 方式工作的版本，起名叫ANSI[1]，从这时开始，WINDOWS 系统终于无需要加装各种本土语言系统，就可以显示全世界上所有文化的字符了。 

**<font size='2'>[1]Windows 里说的「ANSI」其实是 Windows code pages，这个模式根据当前 locale 选定具体的编码，比如简中 locale 下是 GB2312。对于支持 UNICODE的应用程序，Windows 会默认使用 Unicode编码。对于不支持Unicode的应用程序Windows 会采用 ANSI编码 </font>*

​		但是，UNICODE 在制订时没有考虑与任何一种现有的编码方案保持兼容，这使得 GBK 与UNICODE 在汉字的内码编排上完全是不一样的，没有一种简单的算术方法可以把文本内容从UNICODE编码和另一种编码进行转换，这种转换必须通过查表来进行。 

​		如前所述，UNICODE 是用两个字节来表示为一个字符，他总共可以组合出65535不同的字符，这大概已经可以覆盖世界上所有文化的符号。如果还不够也没有关系，ISO已经准备了UCS-4方案，说简单了就是四个字节来表示一个字符，这样我们就可以组合出21亿个不同的字符出来（最高位有其他用途）。

## UTF-8/UTF-16

​		UNICODE 来到时，一起到来的还有计算机网络的兴起，UNICODE 如何在网络上传输也是一个必须考虑的问题，于是面向传输的众多 UTF（UCS Transfer Format）标准出现了，顾名思义，UTF8就是每次8个位传输数据，而UTF16就是每次16个位，只不过为了传输时的可靠性，从UNICODE到 UTF时并不是直接的对应，而是要过一些算法和规则来转换。 

​		在网络里传递信息时有一个很重要的问题，就是对于数据高低位的解读方式，一些计算机是采用低位先发送的方法，例如我们PC机采用的 INTEL 架构；而另一些是采用高位先发送的方式。在网络中交换数据时，为了核对双方对于高低位的认识是否是一致的，采用了一种很简便的方法，就是在文本流的开始时向对方发送一个标志符——如果之后的文本是高位在位，那就发送"FEFF"，反之，则发送"FFFE"。不信你可以用二进制方式打开一个UTF-X格式的文件，看看开头两个字节是不是这两个字节？ 

​		UTF-8需要使用三个字去表示一个非ANSI字符。 

​		UTF规定：如果一个符号只占一个字节，那么这个8位字节的第一位就为0。如果为两个字节，那么规定第一个字节的前两位都为1，然后第一个字节的第三位为0，第二个字节的前两位为10，然后如果是三个字节的话，那么第一个字节的前三位为111，第四位为0，剩余的两个字节的前两位都为10。按照这样的算法去思考一个中文字符的UTF-8是怎么表示的：一个中文字符需要两个字节来表示，两个字节一共是16位，那么UTF-8下，两个字节是不够的，因为两个字节下，第一个字节已经占据了三位：110，然后剩余的一个字节占据了两位：10，现在就只剩下11位，与Unicode下的两个字节，16位去表示任意一个字符是相悖的。所以就使用三个字节去表示非ANSI字符：三个字节下，一共是24位，第一个字节头四位是：1110，后两个字节的前两位都是：10，那么24位-8位=16位，刚好两个字节去表示Unicode下的任意一个非ANSI字符

UTF-8 有以下编码规则：

1. 如果一个字节，最高位（第 8 位）为 0，表示这是一个 ASCII 字符（00 - 7F）。可见，所有 ASCII 编码已经是 UTF-8 了。
2. 如果一个字节，以 11 开头，连续的 1 的个数暗示这个字符的字节数，例如：110xxxxx 代表它是双字节 UTF-8 字符的首字节。
3. 如果一个字节，以 10 开始，表示它不是首字节，需要向前查找才能得到当前字符的首字节

例如"汉"字的Unicode编码是6C49。6C49在0800-FFFF之间，所以要用3字节模板：1110xxxx 10xxxxxx 10xxxxxx。将6C49写成二进制是：0110 1100 0100 1001，将这个比特流按三字节模板的分段方法分为0110 110001 001001，依次代替模板中的x，得到：1110-0110 10-110001 10-001001，即E6 B1 89，这就是其UTF8的编码。

讲到这里，我们再顺便说说一个很著名的奇怪现象：当你在 windows 的记事本里新建一个文件，输入"联通"两个字之后，保存，关闭，然后再次打开，你会发现这两个字已经消失了，代之的是几个乱码。 

​		其实这是因为GB2312编码与UTF8编码产生了编码冲撞的原因。 （ANSI是默认的编码方式。对于英文文件是ASCII编码，对于简体中文文件是GB2312编码（只针对Windows简体中文版，如果是繁体中文版会采用Big5码））。

​		“联”ANSI编码是  0xC1AA 二进制排列是 **110**0 0001   **10**10 1010；	

​		“通”ANSI编码是  0xCDA8 二进制排列是 **110**0 1101  **10**10 1000；

​		巧合的地方在于：“联通”这两个字的ANSI编码符合utf8编码的第二个模板。“联”的两个字节、“通”的两个个字节的起始部分的都是"110"和"10"，正好与UTF8规则里的两字节模板是一致的，于是再次打开记事本时，记事本就误认为这是一个UTF8编码的文件。让我们把第一个字节的110和第二个字节的10去掉，我们就得到了"00001 101010"，再把各位对齐，补上前导的0，就得到了"0000 0000 0110 1010"。

当一个软件打开一个文本时，它要做的第一件事是决定这个文本究竟是使用哪种字符集的哪种编码保存的。软件一般采用三种方式来决定文本的字符集和编码： 

检测文件头标识，提示用户选择，根据一定的规则猜测 



## GBK，UTF-8，UTF-16的关系

首先你要知道UTF-8和UTF-16还有UTF-32是为了方便传输和存储的而产生的对Unicode字符的编码方式。
先说UTF-8，随着全球化Unicode流行起来，不管你做什么，支持Unicode都将是潮流，就算你可能永远也用不到，但这对西方国家就不太好，因为以前ASCII字符集，一个字符只需要一个字节，而现在用Unicode一个英文字母也需要两个字节，如果需要传输和存储，那会浪费一半的空间或流量，所以就想出了一种变长编码方式，那就是UTF-8，它对ASCII字符集内的字符，只用一个字节编码，而其他字符按照一定规则进行两、三、四字节编码，具体规则是：
Unicode编码(十六进制)　   UTF-8 字节流(二进制)
000000 - 00007F                0xxxxxxx
**000080 - 0007FF                110xxxxx 10xxxxxx**
000800 - 00FFFF               1110xxxx 10xxxxxx 10xxxxxx
010000 - 10FFFF               11110xxx 10xxxxxx 10xxxxxx 10xxxxxx

但这样做一些东方国家不干了，因为他们的字符基本都是在000800 - 00FFFF这个区间，用UTF-8反倒要多用一个字节，总共需要三个字节才能表示，而且用UTF-8处理他们的字符，不能直接转换，需要做一些运算，以‘放’为例，它的Unicode码是25918，二进制表示是0110  010100   111110，如果要转成UTF-8，首先取高四位0110，和1110拼接，组成11100110，然后中间六位010100，与10拼接构成10010100，最后低六位111110，与10拼接构成10111110，所以三个字节是11100110 10010100 10111110，也就是十六进制的E6  94 BE，也就是你上面写的-26 -108 -66。可以看到这个运算量虽然不大，基本是位操作，但如果你每个字符都要这么操作实在是有损效率，综合这几点考虑，于是又弄了一个UTF-16，不严谨地来说它等价于Unicode原生编码，它统一采用双字节表示一个字符(其实有四字节区域，但现在一般没有用到)，而由于它用多字节表示，和Unicode一样需要字节序标识，你上面代码里发现它得到-2, -1, 101, 62，转为十六进制就是FE FF 65 3E，和我第二个实例程序中相同，说明UTF-16的码值(如表示‘放’的65 3E)和Unicode原生编码是相同的。

UTF-32的诞生其实也不奇怪，因为UTF-16还是一个变长编码方式，一个字符可能由两个或四个字节表示，有些有强迫症的人总觉得不好，所以为了他们就有了UTF-32，它统一使用四字节表示一个字符，因为用得不多所以不详细说了。

最后说说GBK是个什么东西。GBK是国标扩(展)的拼音首字母，是我国在1995年制定的专门针对汉语和一些少数名族语言的编码方式，和Unicode之间没有一一对应的关系，也就是说Unicode中有的字符GBK不一定有，GBK有的字符Unicode也不一定有，而且GBK和Unicode中共有字符，他们的编码值没有一种简单的对应关系，也就是无法通过简单计算得到，只能通过查表转换。为什么会有GBK这种奇葩呢？其实是当时Unicode还没制定好，更没在全球范围内推广，而中国人要用电脑总不可能永远用英语吧？所以我国就自行制定了一个国标，当时是GB2312，(其实台湾地区针对繁体还有一个Big5，但这里就不详述了)，GB2312后来增加了很多字符，包括很多少数名族的语言，成为了一个新的编码标准，那就是GBK。

unicode 就是 “与存储无关的表示”，utf—8 就是 “二进制表示”。一句话，utf8是对unicode字符集进行编码的一种编码方式，utf8是给unicode字符集加了一个存储类型前缀。

unicode是标准，utf8是一种为了存储和传输unicode的一种方式。

做个简单的比喻, unicode相当于中文, UTF-8, UTF-16等相当于 行书, 楷书, 草书等各种书写方式.

## 编码格式的比较

对中文字符后面四种编码格式都能处理，GB2312 与 GBK 编码规则类似，但是 GBK 范围更大，它能处理所有汉字字符，所以 GB2312 与 GBK 比较应该选择 GBK。UTF-16 与 UTF-8 都是处理 Unicode 编码，它们的编码规则不太相同，相对来说 UTF-16 编码效率最高，字符到字节相互转换更简单，进行字符串操作也更好。它适合在本地磁盘和内存之间使用，可以进行字符和字节之间快速切换，如 Java 的内存编码就是采用 UTF-16 编码。但是它不适合在网络之间传输，因为网络传输容易损坏字节流，一旦字节流损坏将很难恢复，想比较而言 UTF-8 更适合网络传输，对 ASCII 字符采用单字节存储，另外单个字符损坏也不会影响后面其它字符，在编码效率上介于 GBK 和 UTF-16 之间，所以 UTF-8 在编码效率上和编码安全性上做了平衡，是理想的中文编码方式。



# 五、英文字母和中文汉字在不同字符集编码下的字节数

| 编码格式   | 英文字母 | 中文汉字 |
| :--------- | -------- | -------- |
| GB18030    | 1        | 2        |
| GB2312     | 1        | 2        |
| GBK        | 1        | 2        |
| GB18030    | 1        | 2        |
| ISO-8859-1 | 1        | 1        |
| UTF-8      | 1        | 3        |
| UTF-16     | 4        | 4        |

 不同的编码格式占字节数是不同的。

注：本文内容引用：[雨夜听蝉](https://www.cnblogs.com/lslk89/p/6898526.html)